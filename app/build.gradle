apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-android-extensions'
apply plugin: 'io.fabric'
apply plugin: 'com.github.triplet.play'

def getVersionCode = { ->
    def proc = Runtime.getRuntime().exec("git rev-list --all --count")

    def result = proc.waitFor()
    if (result != 0) {
        return 1 // no git revisions
    }

    // Add a million because of previous versionCode problems.
    // Multiply by 10 so LSB can represent build type.
    return (proc.getInputStream().readLines().get(0).toInteger() * 10 ) + 1000000
}

def getVersionName = { ->
    def proc = Runtime.getRuntime().exec("git describe --tags")

    def result = proc.waitFor()
    if (result != 0) {
        return "git-error"
    }

    return proc.getInputStream().readLines().get(0)
}

def getPublishingTrack = { ->
    def branchName = System.getenv("CIRCLE_BRANCH")

    if (branchName.equals("master")) {
        project.logger.quiet("Deploying to production.")
        return "production"
    } else if (branchName.equals("develop")) {
        project.logger.quiet("Deploying to beta.")
        return "beta"
    } else {
        project.logger.quiet("Deploying to alpha.")
        return "alpha"
    }
}

android {
    compileSdkVersion 23
    buildToolsVersion '23.0.3'

    defaultConfig {
        applicationId "net.sigmabeta.chipbox"

        minSdkVersion 21
        targetSdkVersion 21

        versionName getVersionName()
    }

    signingConfigs {
        release {
            storeFile file("chipbox.jks")
            storePassword System.getenv("KEYSTORE_PASSWORD")
            keyAlias System.getenv("KEY_ALIAS")
            keyPassword System.getenv("KEY_PASSWORD")
        }
    }

    buildTypes {
        release {
            signingConfig signingConfigs.release
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }

        debug {
            applicationIdSuffix ".debug"
            versionNameSuffix '-debug'
            jniDebuggable true
        }
    }

    tasks.withType(JavaCompile) { compileTask ->
        compileTask.dependsOn(compileNative)
    }

    productFlavors {
        arm {
            flavorDimension "abi"
            versionCode getVersionCode() + 1

            ndk {
                abiFilter "armeabi-v7a"
            }
        }

        x86 {
            flavorDimension "abi"
            versionCode getVersionCode() + 3

            ndk {
                abiFilter "x86"
            }
        }

        arm_64 {
            flavorDimension "abi"
            versionCode getVersionCode() + 5

            ndk {
                abiFilter "arm64-v8a"
            }
        }

        x86_64 {
            flavorDimension "abi"
            versionCode getVersionCode() + 7

            ndk {
                abiFilter "x86_64"
            }
        }
    }

    lintOptions {
        abortOnError false
    }

    play {
        def email = System.getenv("SERVICE_ACCOUNT_EMAIL")
        project.logger.quiet("Gradle: " + email)
        serviceAccountEmail = email
        pk12File = file('key.p12')
        track = getPublishingTrack()
    }
}

dependencies {
    // Contains Lollipop UI View backports.
    compile 'com.android.support:appcompat-v7:23.4.0'

    // RecyclerView backports.
    compile 'com.android.support:recyclerview-v7:23.4.0'

    // Contains new Material Design views. Automatically includes support-v4
    compile 'com.android.support:design:23.4.0'

    // Enable RxJava-style asynrchronous calls
    compile 'io.reactivex:rxandroid:1.2.0'

    // Display images loaded from storage.
    compile 'com.squareup.picasso:picasso:2.5.2'

    // Contains the Kotlin Standard Library
    compile "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"

    // Copy album art more easily.
    compile 'commons-io:commons-io:2.4'

    // Crash Reporting
    compile('com.crashlytics.sdk.android:crashlytics:2.5.5@aar') {
        transitive = true;
    }

    // Annotation-processing based DB codegen.
    kapt "com.github.Raizlabs.DBFlow:dbflow-processor:${dbflow_version}"
    compile "com.github.Raizlabs.DBFlow:dbflow-core:${dbflow_version}"
    compile "com.github.Raizlabs.DBFlow:dbflow:${dbflow_version}"

    // Dependency Injection.
    compile "com.google.dagger:dagger:${dagger_version}"
    kapt "com.google.dagger:dagger-compiler:${dagger_version}"
    provided 'org.glassfish:javax.annotation:10.0-b28'
}

buildscript {
    ext.kotlin_version = '1.0.3-eap-30'
    ext.dbflow_version = "3.0.0-beta6"
    ext.dagger_version = "2.2"

    repositories {
        mavenCentral()
        maven { url 'https://maven.fabric.io/public' }
        maven { url "https://dl.bintray.com/kotlin/kotlin-eap/" }
    }

    dependencies {
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
        classpath 'io.fabric.tools:gradle:1.21.6'
    }
}

kapt {
    generateStubs = true
}

task setupCMake(type: Exec) {
    String abi = getAbi()

    if (abi == null) {
        executable "echo"
        args "ABI is null, skipping CMake setup."
    } else {

        mkdir('build/' + abi)
        workingDir 'build/' + abi

        executable getExecutablePath("cmake")

        def ndkPath = getNdkPath()

        String ndkArg

        if (ndkPath != null) {
            ndkArg = "-DANDROID_NDK=" + ndkPath
        } else {
            ndkArg = ""
        }

        project.logger.quiet("Gradle: ndkArg: " + ndkArg)

        args "-DANDROID=true",
                "-DANDROID_NATIVE_API_LEVEL=android-21",
                "-DCMAKE_TOOLCHAIN_FILE=../../../android.toolchain.cmake",
                ndkArg,
                "../../src/main/cpp/",
                "-DANDROID_TOOLCHAIN_NAME=" + getToolchainName(),
                "-DANDROID_ABI=" + abi
    }
}

task compileNative(type: Exec, dependsOn: 'setupCMake') {
    String abi = getAbi()

    if (abi == null) {
        executable "echo"
        args "ABI is null, skipping native build."
    } else {
        workingDir 'build/' + abi
        executable 'make'
    }
}

String getAbi() {
    String taskName = getGradle().startParameter.taskNames[0]
    String abi;

    if (taskName == null) {
        return ""
    }

    project.logger.quiet("Gradle: Build = " + taskName)

    if (taskName.contains("Arm_64")) {
        abi = "arm64-v8a"
    } else if (taskName.contains("Arm")) {
        abi = "armeabi-v7a"
    } else if (taskName.contains("X86_64")) {
        abi = "x86_64"
    } else if (taskName.contains("X86")) {
        abi = "x86"
    }

    project.logger.quiet("Gradle: ABI name: " + abi)
    return abi;
}

String getToolchainName() {
    String taskName = getGradle().startParameter.taskNames[0]
    String toolchain;

    if (taskName == null) {
        return ""
    }

    if (taskName.contains("Arm_64")) {
        toolchain = "aarch64-linux-android-4.9"
    } else if (taskName.contains("Arm")) {
        toolchain = "arm-linux-androideabi-4.9"
    } else if (taskName.contains("X86_64")) {
        toolchain = "x86_64-4.9"
    } else if (taskName.contains("X86")) {
        toolchain = "x86-4.9"
    }

    project.logger.quiet("Gradle: Toolchain name: " + toolchain)
    return toolchain;
}

String getNdkPath() {
    def propsFile = rootProject.file("build.properties")
    def ndkPath = null

    if (propsFile.canRead()) {
        def buildProperties = new Properties()
        buildProperties.load(new FileInputStream(propsFile))
        ndkPath = buildProperties.ndkPath
    }

    if (ndkPath == null || ndkPath.isEmpty()) {
        try {
            def stdout = new ByteArrayOutputStream()

            exec {
                // ndk-build.cmd is a file unique to the root directory of android-ndk-r10e.
                commandLine 'locate', 'ndk-build.cmd'
                standardOutput = stdout
            }

            def ndkCmdPath = stdout.toString()
            ndkPath = ndkCmdPath.substring(0, ndkCmdPath.lastIndexOf('/'))
        } catch (ignored) {
            project.logger.error("Gradle error: Couldn't find NDK.")
        }
    }

    if (ndkPath != null) {
        project.logger.quiet("Gradle: Found Android NDK: " + ndkPath)
    }
    return ndkPath
}

String getExecutablePath(String command) {
    def propsFile = rootProject.file("build.properties")
    def path = null

    if (propsFile.canRead()) {
        def buildProperties = new Properties()
        buildProperties.load(new FileInputStream(propsFile))
        println buildProperties
        path = buildProperties[command + "Path"]
    }

    if (path == null || path.isEmpty()) {
        try {
            def stdout = new ByteArrayOutputStream()

            exec {
                commandLine 'which', command
                standardOutput = stdout
            }

            path = stdout.toString().trim()
        } catch (ignored) {
            project.logger.error("Gradle error: Couldn't find " + command + " executable.")
        }
    }

    if (path != null) {
        project.logger.quiet("Gradle: Found " + command + " executuable:" + path)
    }

    return path
}